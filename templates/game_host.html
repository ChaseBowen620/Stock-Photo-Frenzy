{% extends "base.html" %}

{% block title %}Game - Stock Photo Frenzy (Host){% endblock %}

{% block content %}
<div class="container">
    <header>
        <h1><a href="{{ url_for('index') }}" id="home-link" style="color: inherit; text-decoration: none;">Stock Photo Frenzy - Host</a></h1>
        <p>Round <span id="round-number">1</span> of <span id="max-rounds">5</span></p>
        <div id="mode-indicator" class="mode-indicator"></div>
        <div id="team-indicator" class="team-indicator" style="display: none;"></div>
    </header>
    
    <main>
        <div class="game-stats">
            <div class="stat-banner round-banner">
                <span class="stat-label">Round:</span>
                <span id="round" class="stat-value">1/5</span>
            </div>
            <div class="stat-banner timer-banner">
                <span class="stat-label">Time:</span>
                <span id="timer" class="stat-value timer-value">1:00</span>
            </div>
            <div class="stat-banner forfeit-banner">
                <button id="forfeit-btn" onclick="forfeitRound()" class="btn-forfeit-stat">Forfeit</button>
            </div>
            <div id="shared-score-banner" class="stat-banner score-banner" style="display: none;">
                <span class="stat-label">Shared Score:</span>
                <span id="shared-score" class="stat-value">0</span>
            </div>
        </div>
        
        <div class="image-container">
            <div id="loadingSpinner" class="loading-spinner" style="display: none;">
                <div class="spinner"></div>
                <p>Loading your challenge image...</p>
            </div>
            
            <div id="imageDisplay" class="image-display" style="display: none;">
                <img id="randomImage" src="" alt="Random stock photo">
                <div class="image-info">
                    <h3 id="imageTitle">_ _ _ _ _ _ _ _ _ _ _</h3>
                    <div class="image-meta">
                        <span id="imageId">ID: </span>
                        <span id="imageContributor">Contributor: </span>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="leaderboard" class="leaderboard-container" style="display: none;">
            <h3>Leaderboard</h3>
            <div id="leaderboard-list"></div>
        </div>
        
        <div class="host-controls">
            <button id="next-round-btn" onclick="nextRound()" class="btn-primary" style="display: none;">
                Next Round
            </button>
        </div>
    </main>
</div>

<script>
const lobbyId = '{{ lobby_id }}';
let currentRound = 0;
let maxRounds = 5;
let currentImage = null;
let originalTitle = '';
let titleWords = [];
let easyModeHiddenWords = [];
let revealedWords = [];
let wordOwners = {};
let gameMode = 'free-for-all';
let difficulty = 'hard';
let activeTeam = null;
let pollInterval;
let timeLeft = 60;
let timerInterval = null;

async function checkGameStatus() {
    const response = await fetch(`/api/lobby/${lobbyId}/status`);
    const data = await response.json();
    
    if (data.lobby.status === 'active') {
        gameMode = data.lobby.game_mode;
        difficulty = data.lobby.difficulty;
        maxRounds = 5;  // All modes use 5 rounds
        document.getElementById('max-rounds').textContent = maxRounds;
        
        // Update mode indicator
        const modeNames = {
            'free-for-all': 'Free-for-All',
            'competitive': 'Competitive',
            'cooperative': 'Cooperative'
        };
        document.getElementById('mode-indicator').textContent = modeNames[gameMode] + ' Mode';
        
        // Show shared score for cooperative
        if (gameMode === 'cooperative') {
            document.getElementById('shared-score-banner').style.display = 'flex';
        }
        
        if (data.lobby.current_image_data) {
            setupGame(data.lobby.current_image_data);
            // Start timer when game is set up
            if (!timerInterval) {
                timeLeft = 60;
                updateTimerDisplay();
                startTimer();
            }
        } else {
            startRound();
        }
    } else {
        setTimeout(checkGameStatus, 1000);
    }
}

async function startRound() {
    if (currentRound >= maxRounds) {
        window.location.href = `/results?lobby=${lobbyId}`;
        return;
    }
    
    currentRound++;
    document.getElementById('round-number').textContent = currentRound;
    document.getElementById('round').textContent = `${currentRound}/${maxRounds}`;
    document.getElementById('next-round-btn').style.display = 'none';
    document.getElementById('forfeit-btn').style.display = 'block';
    document.getElementById('leaderboard').style.display = 'none';
    
    // Reset and start timer
    timeLeft = 60;
    updateTimerDisplay();
    startTimer();
    
    // Update team indicator for competitive
    if (gameMode === 'competitive') {
        const response = await fetch(`/api/lobby/${lobbyId}/status`);
        const data = await response.json();
        activeTeam = data.lobby.active_team;
        const teamIndicator = document.getElementById('team-indicator');
        teamIndicator.style.display = 'block';
        
        // Round 5 (index 4, 0-indexed) is free-for-all
        // Round 1 (index 0): red, Round 2 (index 1): blue, Round 3 (index 2): red, Round 4 (index 3): blue, Round 5 (index 4): both
        if (currentRound === 5) { // Display shows 1-indexed, but currentRound is 1-indexed in display
            teamIndicator.textContent = 'FINAL ROUND - Both Teams!';
            teamIndicator.className = 'team-indicator team-final';
        } else {
            teamIndicator.textContent = `${activeTeam.toUpperCase()} Team's Turn`;
            teamIndicator.className = `team-indicator team-${activeTeam}`;
        }
    }
    
    document.getElementById('loadingSpinner').style.display = 'block';
    document.getElementById('imageDisplay').style.display = 'none';
    
    try {
        // Get difficulty and phrases from lobby
        const lobbyResponse = await fetch(`/api/lobby/${lobbyId}/status`);
        const lobbyData = await lobbyResponse.json();
        difficulty = lobbyData.lobby.difficulty || 'hard';
        
        let imageUrl = `/api/get-image?difficulty=${difficulty}`;
        
        // For competitive mode, use team phrases
        if (gameMode === 'competitive') {
            if (currentRound === 5) {
                // Round 5: Get photos from both team phrases, then randomly select one
                const redPhrase = lobbyData.lobby.red_team_phrase;
                const bluePhrase = lobbyData.lobby.blue_team_phrase;
                
                // Randomly choose which team gets 3 photos and which gets 2
                const redGets3 = Math.random() < 0.5;
                const redPerPage = redGets3 ? 3 : 2;
                const bluePerPage = redGets3 ? 2 : 3;
                
                try {
                    let allImages = [];
                    
                    // Fetch from red team
                    if (redPhrase) {
                        try {
                            const redResponse = await fetch(`/api/get-image?difficulty=${difficulty}&query=${encodeURIComponent(redPhrase)}&per_page=${redPerPage}`);
                            const redData = await redResponse.json();
                            if (redData.success && redData.images) {
                                allImages = allImages.concat(redData.images);
                            }
                        } catch (e) {
                            console.log('Error fetching red team photos, continuing...');
                        }
                    }
                    
                    // Fetch from blue team
                    if (bluePhrase) {
                        try {
                            const blueResponse = await fetch(`/api/get-image?difficulty=${difficulty}&query=${encodeURIComponent(bluePhrase)}&per_page=${bluePerPage}`);
                            const blueData = await blueResponse.json();
                            if (blueData.success && blueData.images) {
                                allImages = allImages.concat(blueData.images);
                            }
                        } catch (e) {
                            console.log('Error fetching blue team photos, continuing...');
                        }
                    }
                    
                    if (allImages.length > 0) {
                        const randomImage = allImages[Math.floor(Math.random() * allImages.length)];
                        setupGame(randomImage);
                    } else {
                        // Fallback to random
                        const fallbackResponse = await fetch(`/api/get-image?difficulty=${difficulty}`);
                        const fallbackData = await fallbackResponse.json();
                        if (fallbackData.error) throw new Error(fallbackData.error);
                        setupGame(fallbackData.image);
                    }
                } catch (error) {
                    console.error('Error in round 5 image selection:', error);
                    // Fallback to random
                    const fallbackResponse = await fetch(`/api/get-image?difficulty=${difficulty}`);
                    const fallbackData = await fallbackResponse.json();
                    if (fallbackData.error) throw new Error(fallbackData.error);
                    setupGame(fallbackData.image);
                }
                return; // Exit early for round 5
            } else {
                // Rounds 1-4: Use the opposite team's phrase
                const activeTeam = lobbyData.lobby.active_team;
                const phrase = activeTeam === 'red' ? lobbyData.lobby.blue_team_phrase : lobbyData.lobby.red_team_phrase;
                if (phrase) {
                    imageUrl += `&query=${encodeURIComponent(phrase)}`;
                }
            }
        }
        
        const response = await fetch(imageUrl);
        const data = await response.json();
        
        if (data.error) {
            // Fallback to random
            const fallbackResponse = await fetch(`/api/get-image?difficulty=${difficulty}`);
            const fallbackData = await fallbackResponse.json();
            if (fallbackData.error) throw new Error(fallbackData.error);
            setupGame(fallbackData.image);
        } else {
            setupGame(data.image);
        }
        
        // Store image in lobby
        await fetch(`/api/lobby/${lobbyId}/next-round`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ image_data: data.image })
        });
    } catch (error) {
        console.error('Error loading image:', error);
        alert('Failed to load image. Please try again.');
    } finally {
        document.getElementById('loadingSpinner').style.display = 'none';
    }
}

function setupGame(image) {
    currentImage = image;
    originalTitle = image.title;
    titleWords = image.title_words || [];
    easyModeHiddenWords = image.easy_mode_hidden_words || [];
    
    document.getElementById('randomImage').src = image.url;
    document.getElementById('imageId').textContent = `ID: ${image.id}`;
    document.getElementById('imageContributor').textContent = `Contributor: ${image.contributor}`;
    
    displayHiddenTitle();
    document.getElementById('imageDisplay').style.display = 'block';
    
    // Start timer when game is set up
    if (!timerInterval) {
        timeLeft = 60;
        updateTimerDisplay();
        startTimer();
    }
    
    startPolling();
}

function displayHiddenTitle() {
    const allWords = originalTitle.toLowerCase()
        .replace(/[^\w\s]/g, ' ')
        .split(/\s+/)
        .filter(word => word.length > 0);
    
    let displayTitle = originalTitle;
    
    allWords.forEach((word) => {
        if (titleWords.includes(word)) {
            if (revealedWords.includes(word)) {
                // Word is revealed - check if we need to color it (Free-for-All mode or Competitive round 5)
                if ((gameMode === 'free-for-all' || (gameMode === 'competitive' && currentRound === 5)) && wordOwners[word]) {
                    // We'll get participant info from polling, but for now use a placeholder
                    // The actual coloring will be done in the polling function
                    const wordRegex = new RegExp(`\\b${word}\\b`, 'gi');
                    displayTitle = displayTitle.replace(wordRegex, word);
                }
            } else {
                // Word is hidden - check if easy mode
                if (difficulty === 'easy' && !easyModeHiddenWords.includes(word)) {
                    // Show word in easy mode
                    return;
                }
                // Hide word
                const wordRegex = new RegExp(`\\b${word}\\b`, 'gi');
                displayTitle = displayTitle.replace(wordRegex, '_'.repeat(word.length));
            }
        }
    });
    
    // Apply color highlighting if needed
    if ((gameMode === 'free-for-all' || (gameMode === 'competitive' && currentRound === 5)) && Object.keys(wordOwners).length > 0) {
        // Get participant colors from current state
        fetch(`/api/lobby/${lobbyId}/status`).then(r => r.json()).then(data => {
            let highlightedTitle = displayTitle;
            Object.keys(wordOwners).forEach(word => {
                if (revealedWords.includes(word)) {
                    const owner = data.participants.find(p => p.player_name === wordOwners[word]);
                    if (owner) {
                        let color = owner.player_color;
                        if (!color && gameMode === 'competitive') {
                            color = owner.team === 'red' ? '#e74c3c' : '#3498db';
                        }
                        if (color) {
                            const wordRegex = new RegExp(`\\b${word}\\b`, 'gi');
                            highlightedTitle = highlightedTitle.replace(wordRegex, 
                                `<span style="background-color: ${color}; color: white; padding: 2px 4px; border-radius: 3px;">${word}</span>`);
                        }
                    }
                }
            });
            document.getElementById('imageTitle').innerHTML = highlightedTitle;
        });
    } else {
        document.getElementById('imageTitle').innerHTML = displayTitle;
    }
}

function startPolling() {
    pollInterval = setInterval(async () => {
        const response = await fetch(`/api/lobby/${lobbyId}/status`);
        const data = await response.json();
        
        if (data.lobby.current_image_data) {
            const imageData = data.lobby.current_image_data;
            if (imageData.title_words) {
                titleWords = imageData.title_words;
                originalTitle = imageData.title;
                easyModeHiddenWords = imageData.easy_mode_hidden_words || [];
            }
        }
        
        // Check if lobby was ended
        if (data.lobby.status === 'ended') {
            window.location.href = '/';
            return;
        }
        
        // Always update revealed words from server to show immediately when guessed
        const serverRevealedWords = data.lobby.revealed_words || [];
        revealedWords = serverRevealedWords;
        wordOwners = data.lobby.word_owners || {};
        
        displayHiddenTitle();
        
        // Update scores
        if (gameMode === 'cooperative') {
            document.getElementById('shared-score').textContent = data.lobby.shared_score || 0;
        } else {
            updateLeaderboard(data.participants);
        }
        
        // Check if all words revealed
        const wordsToReveal = (easyModeHiddenWords.length > 0) ? easyModeHiddenWords : titleWords;
        const allWordsRevealed = wordsToReveal.length > 0 && wordsToReveal.every(word => revealedWords.includes(word));
        
        if (allWordsRevealed) {
            stopTimer();
            document.getElementById('forfeit-btn').style.display = 'none';
            document.getElementById('next-round-btn').style.display = 'block';
        }
        
        // Update active team for competitive
        if (gameMode === 'competitive') {
            const newActiveTeam = data.lobby.active_team;
            const currentRoundNum = data.lobby.current_round || 0;
            const isRound5 = currentRoundNum === 4; // 0-indexed, so round 5 is index 4
            
            if (newActiveTeam !== activeTeam || isRound5) {
                activeTeam = newActiveTeam;
                const teamIndicator = document.getElementById('team-indicator');
                
                // Round 5 is free-for-all
                if (isRound5) {
                    teamIndicator.textContent = 'FINAL ROUND - Both Teams!';
                    teamIndicator.className = 'team-indicator team-final';
                } else {
                    teamIndicator.textContent = `${activeTeam.toUpperCase()} Team's Turn`;
                    teamIndicator.className = `team-indicator team-${activeTeam}`;
                }
            }
        }
    }, 1000);
}

function updateLeaderboard(participants) {
    const sorted = [...participants].sort((a, b) => b.score - a.score);
    const list = document.getElementById('leaderboard-list');
    
    let html = '<div class="leaderboard-items">';
    sorted.forEach((p, index) => {
        const colorStyle = gameMode === 'free-for-all' && p.player_color 
            ? `style="border-left: 4px solid ${p.player_color};"` 
            : '';
        const teamBadge = gameMode === 'competitive' && p.team
            ? `<span class="team-badge team-${p.team}">${p.team}</span>`
            : '';
        html += `
            <div class="leaderboard-item" ${colorStyle}>
                <span class="rank">${index + 1}</span>
                <span class="name">${p.player_name} ${teamBadge}</span>
                <span class="score">${p.score} pts</span>
            </div>
        `;
    });
    html += '</div>';
    list.innerHTML = html;
    document.getElementById('leaderboard').style.display = 'block';
}

// Round scoreboard removed - only showing total leaderboard

function startTimer() {
    stopTimer(); // Clear any existing timer
    timerInterval = setInterval(() => {
        timeLeft--;
        updateTimerDisplay();
        
        if (timeLeft <= 0) {
            stopTimer();
            // Reveal all words when time runs out
            const wordsToReveal = (easyModeHiddenWords.length > 0) ? easyModeHiddenWords : titleWords;
            wordsToReveal.forEach(word => {
                if (!revealedWords.includes(word)) {
                    revealedWords.push(word);
                }
            });
            
            // Update lobby with revealed words
            fetch(`/api/lobby/${lobbyId}/reveal-all`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ revealed_words: revealedWords })
            });
            
            displayHiddenTitle();
            document.getElementById('forfeit-btn').style.display = 'none';
            // Auto-advance to next round when time runs out
            document.getElementById('next-round-btn').style.display = 'block';
        }
    }, 1000);
}

function stopTimer() {
    if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
    }
}

function updateTimerDisplay() {
    const minutes = Math.floor(timeLeft / 60);
    const seconds = timeLeft % 60;
    const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    
    const timerElement = document.getElementById('timer');
    timerElement.textContent = timeString;
    
    timerElement.className = 'stat-value timer-value';
    if (timeLeft <= 10) {
        timerElement.classList.add('danger');
    } else if (timeLeft <= 30) {
        timerElement.classList.add('warning');
    }
}

async function nextRound() {
    stopTimer();
    try {
        const response = await fetch(`/api/lobby/${lobbyId}/next-round`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({}) // Explicitly send empty JSON
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            console.error('Error response:', errorText);
            throw new Error(`Server error: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (data.game_finished) {
            window.location.href = `/results?lobby=${lobbyId}`;
        } else {
            if (pollInterval) {
                clearInterval(pollInterval);
            }
            startRound();
        }
    } catch (error) {
        console.error('Error advancing to next round:', error);
        alert('Failed to advance to next round. Please try again.');
    }
}

// Handle host leaving - end the lobby
document.getElementById('home-link').addEventListener('click', function(e) {
    e.preventDefault();
    if (confirm('Are you sure you want to leave? This will end the game for all players.')) {
        fetch(`/api/lobby/${lobbyId}/end`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        }).then(() => {
            window.location.href = '/';
        });
    }
});

// Handle page unload
window.addEventListener('beforeunload', function() {
    fetch(`/api/lobby/${lobbyId}/end`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
    });
});

function forfeitRound() {
    stopTimer();
    // Reveal all words
    const wordsToReveal = (easyModeHiddenWords.length > 0) ? easyModeHiddenWords : titleWords;
    wordsToReveal.forEach(word => {
        if (!revealedWords.includes(word)) {
            revealedWords.push(word);
        }
    });
    
    // Update lobby with revealed words
    fetch(`/api/lobby/${lobbyId}/reveal-all`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ revealed_words: revealedWords })
    });
    
    displayHiddenTitle();
    document.getElementById('forfeit-btn').style.display = 'none';
    document.getElementById('next-round-btn').style.display = 'block';
}

checkGameStatus();
</script>
{% endblock %}
